# 爱编程的大丙C++11新特性

https://subingwen.cn/cplusplus/

## 1. 稳定性和兼容性



### 原始字面量

定义方式为：R “xxx(原始字符串)xxx”      其中（）两边的字符串可以省略。

强调一个细节：在R “xxx(raw string)xxx” 中，原始字符串必须用括号（）括起来，括号的前后可以加其他字符串，所加的字符串会被忽略，并且加的字符串必须在括号两边同时出现。

原始字面量R可以直接表示字符串的实际含义，而不需要额外对字符串做转义或连接等操作。

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string str = "D:\hello\world\test.text";
    cout << str << endl;
    string str1 = "D:\\hello\\world\\test.text";
    cout << str1 << endl;
    string str2 = R"(D:\hello\world\test.text)";
    cout << str2 << endl;
    return 0;
}
```

```C++
输出的结果为:

1 D:helloworld    est.text
2 D:\hello\world\test.text
3 D:\hello\world\test.text
```

在D:\hello\world\test.text中\h和\w转义失败，对应的字符会原样输出
在D:\\hello\\world\\test.text中路径的间隔符为\但是这个字符又是转义字符，因此需要使用转义字符将其转义，最终才能得到一个没有特殊含义的普通字符\
在R"(D:\hello\world\test.text)"使用了原始字面量R（）中的内容就是描述路径的原始字符串，无需做任何处理



### long long 整形

```C++
long long - 对应类型的数值可以使用 LL (大写) 或者 ll (小写) 后缀

C++
1 long long num1 = 123456789LL;
2 long long num2 = 123456789ll;
```

```C++

unsigned long long - 对应类型的数值可以使用 ULL (大写) 或者 ull (小写) 或者 Ull、uLL (等大小写混合)后缀

C++
1 unsigned long long num1 = 123456789ULL;
2 unsigned long long num2 = 123456789ull;
3 unsigned long long num3 = 123456789uLL;
4 unsigned long long num4 = 123456789Ull;
```

![image-20240118152141559](爱编程的大丙C++11新特性.assets/image-20240118152141559.png)

![image-20240118153603495](爱编程的大丙C++11新特性.assets/image-20240118153603495.png)



### 类成员的快速初始化

```C++
class Test
{
private:
    int a = 9;     // C++11 对非静态成员变量进行初始化，在初始化的时候可以使用等号 = 也可以使用花括号 {}
    int b = {5};   // C++98 非静态成员变量的初始化则必须在构造函数中进行。
    int c{12};
    double array[4] = { 3.14, 3.15, 3.16, 3.17};
    double array1[4] { 3.14, 3.15, 3.16, 3.17 };
    string s1("hello");     // error    不能使用小括号() 初始化对象，应该使用花括号{}
    string s2{ "hello, world" };
};
```

同时在类内部对非静态成员变量就地初始化和在初始化列表中进行初始化会怎么样呢？

```C++
class Init
{
public:
    Init(int x, int y, int z) :a(x), b(y), c(z) {}

    int a = 1;
    int b = 2;
    int c = 3;
};

int main()
{
    Init tmp(10, 20, 30);
    cout << "a: " << tmp.a << ", b: " << tmp.b << ", c: " << tmp.c << endl;
    return 0;
}
```

结果：a: 10, b: 20, c: 30

我们可以从函数的打印输出中看到，在类内部就地初始化和初始化列表并不冲突（程序可以正常运行）。程序员可以为同一成员变量既在类内部就地初始化，又在初始化列表中进行初始化，只不过初始化列表总是看起来后作用于非静态成员。也就是说，通过初始化列表指定的值会覆盖就地初始化时指定的值。



### final和override

#### final

final关键字来限制某个类不能被继承，或者某个虚函数不能被重写

```C++
// 1）修饰函数
class Base
{
public:
    virtual void test()
    {
        cout << "Base class...";
    }
};

class Child : public Base
{
public:
    void test() final
    {
        cout << "Child class...";
    }
};

class GrandChild : public Child
{
public:
    // 语法错误, 不允许重写
    void test()
    {
        cout << "GrandChild class...";
    }
};


// 2）修饰类
class Base
{
public:
    virtual void test()
    {
        cout << "Base class...";
    }
};

class Child final: public Base
{
public:
    void test()
    {
        cout << "Child class...";
    }
};

// error, 语法错误
class GrandChild : public Child
{
public:
};
```





#### override

override关键字确保在派生类中声明的重写函数与基类的虚函数有相同的签名，同时也明确表明将会重写基类的虚函数，这样就可以保证重写的虚函数的正确性，也提高了代码的可读性，和final一样这个关键字要写到方法的后面。

<img src="爱编程的大丙C++11新特性.assets/image-20240122155745122.png" alt="image-20240122155745122" style="zoom:80%;" />



### 模板的优化

在泛型编程中，模板实例化有一个非常繁琐的地方，那就是连续的**两个右尖括号（>>）会被编译器解析成右移操作符**，而不是模板参数表的结束。

#### 默认模板参数

在C++98/03标准中，类模板可以有默认的模板参数：

```C++
#include <iostream>
using namespace std;

template <typename T=int, T t=520>
class Test
{
public:
    void print()
    {
        cout << "current value: " << t << endl;
    }
};

int main()
{
    Test<> t;
    t.print();

    Test<int, 1024> t1;
    t1.print();

    return 0;
}
```

但是不支持函数的默认模板参数，在C++11中添加了对函数模板默认参数的支持:

```C++
#include <iostream>
using namespace std;

template <typename T=int>	// C++98/03不支持这种写法, C++11中支持这种写法
void func(T t)
{
    cout << "current value: " << t << endl;
}

int main()
{
    func(100);
    return 0;
}
```

通过上面的例子可以得到如下结论：当所有模板参数都有默认参数时，函数模板的调用如同一个普通函数。但**对于类模板而言，哪怕所有参数都有默认参数，在使用时也必须在模板名后跟随<>来实例化。**

另外：函数模板的默认模板参数在使用规则上和其他的默认参数也有一些不同，它没有必须写在参数表最后的限制。这样当默认模板参数和模板参数自动推导结合起来时，书写就显得非常灵活了。



当默认模板参数和模板参数自动推导同时使用时（优先级从高到低）：

1. 如果可以推导出参数类型则使用推导出的类型

2. 如果函数模板无法推导出参数类型，那么编译器会使用默认模板参数
3. 如果无法推导出模板参数类型并且没有设置默认模板参数，编译器就会报错。



### 数值类型和字符串之间的转换

#### 1. 数值转换为字符串

```C++
// 头文件 <string>
string to_string (int val);
string to_string (long val);
string to_string (long long val);
string to_string (unsigned val);
string to_string (unsigned long val);
string to_string (unsigned long long val);
string to_string (float val);
string to_string (double val);
string to_string (long double val);
```

#### 2. 字符串转换为数值

```C++
// 定义于头文件 <string>
int       stoi( const std::string& str, std::size_t* pos = 0, int base = 10 );
long      stol( const std::string& str, std::size_t* pos = 0, int base = 10 );
long long stoll( const std::string& str, std::size_t* pos = 0, int base = 10 );

unsigned long      stoul( const std::string& str, std::size_t* pos = 0, int base = 10 );
unsigned long long stoull( const std::string& str, std::size_t* pos = 0, int base = 10 );

float       stof( const std::string& str, std::size_t* pos = 0 );
double      stod( const std::string& str, std::size_t* pos = 0 );
long double stold( const std::string& str, std::size_t* pos = 0 );
```

1. str：要转换的字符串

2. pos：传出参数, 记录从哪个字符开始无法继续进行解析, 比如: 123abc, 传出的位置为3
3. base：若 base 为 0 ，则自动检测数值进制：若前缀为 0 ，则为八进制，若前缀为 0x 或 0X，则为十六进制，否则为十进制。

### 静态断言 static_assert

#### 1. 断言

断言（assertion）是一种编程中常用的手段。在通常情况下，断言就是将一个返回值总是需要为真的判断表达式放在语句中，用于排除在设计的逻辑上不应该产生的情况。

比如：一个函数总需要输入在一定的范围内的参数，那么程序员就可以对该参数使用断言，以迫使在该参数发生异常的时候程序退出，从而避免程序陷入逻辑的混乱。 

从一些意义上讲，断言并不是正常程序所必需的，不过对于程序调试来说，通常断言能够帮助程序开发者快速定位那些违反了某些前提条件的程序错误。

如果我们要在C++程序中使用断言，需要在程序中包含头文件**<cassert>或<assert.h>**，头文件中为我们提供了 assert 宏，用于在运行时进行断言。举例说明：

```C++
#include <iostream>
#include <cassert>
using namespace std;

// 创建一个指定大小的 char 类型数组
char* createArray(int size)
{
    // 通过断言判断数组大小是否大于0
    assert(size > 0);	// 必须大于0, 否则程序中断
    char* array = new char[size];
    return array;
}

int main()
{
    char* buf = createArray(0);
    // 此处使用的是vs提供的安全函数, 也可以使用 strcpy
    strcpy_s(buf, 16, "hello, world!");
    cout << "buf = " << buf << endl;
    delete[]buf;
    return 0;
}
```

在程序的第9行，使用了断言assert(expression) ，这是一个宏，它的参数是一个表达式，这个表达式通常返回一个布尔类型的值，并且要求表达式必须为 true 程序才能继续向下执行，否则会直接中断。

#### 2. 静态断言

在上面的例子中我们使用了断言 assert。但 assert是一个运行时断言，也就是说它只有在程序运行时才能起作用 。这意味着不运行程序我们将无法得知某些条件是否是成立的。 比如：我们想知道当前是32位还是64位平台，对于这个需求我们应该是在程序运行之前就应该得到结果，如果使用断言显然是无法做到的，对于这种情况我们就需要使用C++11提供的静态断言了。

静态断言static_assert，所谓静态就是在编译时就能够进行检查的断言，使用时不需要引用头文件。静态断言的另一个好处是，可以自定义违反断言时的错误提示信息。静态断言使用起来非常简单，它接收两个参数：

参数1：断言表达式，这个表达式通常需要返回一个 bool值
参数2：警告信息，它通常就是一段字符串，**在违反断言（表达式为false）时提示该信息**

```C++
// assert.cpp
#include <iostream>                                         
using namespace std;
  
int main()
{
    // 字体原因看起来是一个=, 其实这是两个=
    static_assert(sizeof(long) == 4, "错误, 不是32位平台...");
    cout << "64bit Linux 指针大小: " << sizeof(char*) << endl;
    cout << "64bit Linux long 大小: " << sizeof(long) <<endl;
  
    return 0;
}
```

![image-20240125142157818](爱编程的大丙C++11新特性.assets/image-20240125142157818.png)



### noexcept

#### 1 基本语法

异常通常用于处理逻辑上可能发生的错误，在C++98中为我们提供了一套完善的异常处理机制，我们可以直接在程序中将各种类型的异常抛出，从而强制终止程序的运行。

![image-20240125142312497](爱编程的大丙C++11新特性.assets/image-20240125142312497.png)

```C++
int main()
{ 
    try
    {
        throw -1; 
    } 
    catch (int e)
    { 
        cout << "int exception, value: " << e << endl; 
    } 
    cout << "That's ok!" << endl; 
    return 0; 
}
```

#### 2 异常接口声明

##### 2.1显示指定可以抛出的异常类型

```C++
struct MyException
{
    MyException(string s) :msg(s) {}
    string msg;
};

double divisionMethod(int a, int b) throw(MyException, int)
{
    if (b == 0)
    {
        throw MyException("division by zero!!!");
        // throw 100;
    }
    return a / b;
}

int main()
{
    try
    {	
        double v = divisionMethod(100, 0);
        cout << "value: " << v << endl;
    }
    catch (int e)
    {
        cout << "catch except: "  << e << endl;
    }
    catch (MyException e)
    {
        cout << "catch except: " << e.msg << endl;
    }
    return 0;
}
```

第7行代码在divisionMethod函数后添加了throw异常接口声明，其参数表示可以抛出的异常类型，分别为int 和MyException 类型。

##### 2.2抛出任意异常类型

```C++
struct MyException
{
    MyException(string s) :msg(s) {}
    string msg;
};

double divisionMethod(int a, int b)
{
    if (b == 0)
    {
        throw MyException("division by zero!!!");
        // throw 100;
    }
    return a / b;
}
```

第7行代码在divisionMethod 没有添加异常接口声明，表示在该函数中可以抛出任意类型的异常。

##### 2.3不抛出任何异常 noexccept

```C++
struct MyException
{
    MyException(string s) :msg(s) {}
    string msg;
};

double divisionMethod(int a, int b) throw()
{
    if (b == 0)
    {
        cout << "division by zero!!!" << endl;
    }
    return a / b;
}
```

第7行代码在divisionMethod 函数后添加了throw异常接口声明，其参数列表为空，表示该函数不允许抛出异常。

**直接使用except的方式**

#### 3 noexcept

在 divisionMethod 函数声明之后，我们定义了一个动态异常声明 throw(MyException, int)，该声明指出了divisionMethod可能抛出的异常的类型。事实上，该特性很少被使用，因此在**C++11中被弃用**了 ，而表示函数不会抛出异常的动态异常声明 throw() 也被新的 noexcept 异常声明所取代。 

noexcept 形如其名，表示其修饰的函数不会抛出异常 。不过与 `throw()`动态异常声明不同的是，`在 C++11 中如果 noexcept 修饰的函数抛出了异常，编译器可以选择直接调用 std::terminate() 函数来终止程序的运行，这比基于异常机制的 throw() 在效率上会高一些`。这是因为异常机制会带来一些额外开销，比如函数抛出异常，会导致函数栈被依次地展开（栈解旋），并自动调用析构函数释放栈上的所有对象。
因此对于不会抛出异常的函数我们可以这样写:

```C++
double divisionMethod(int a, int b) noexcept
{
    if (b == 0)
    {
        cout << "division by zero!!!" << endl;
        return -1;
    }
    return a / b;
}
```

从语法上讲，noexcept 修饰符有两种形式：

简单地在函数声明后加上 noexcept 关键字

可以接受一个常量表达式作为参数，如下所示∶

```C++
double divisionMethod(int a, int b) noexcept(常量表达式);
```

常量表达式的结果会被转换成一个bool类型的值：

值为 true，表示函数不会抛出异常
值为 false，表示有可能抛出异常这里
不带常量表达式的noexcept相当于声明了noexcept（true），即不会抛出异常。



## 2. 易学和易用性

### 自动类型推导 auto

**使用auto声明的变量必须要进行初始化，以让编译器推导出它的实际类型，在编译时将auto占位符替换为真正的类型**

auto还可以和指针、引用结合起来使用也可以带上const、volatile限定符，在不同的场景下有对应的推导规则，规则内容如下：

***当变量不是指针或者引用类型时，推导的结果中不会保留const、volatile关键字***
***当变量是指针或者引用类型时，推导的结果中会保留const、volatile关键字***

```C++
int tmp = 250;
const auto a1 = tmp;
auto a2 = a1;
const auto &a3 = tmp;
auto &a4 = a3;
```

变量a1的数据类型为 const int，因此auto关键字被推导为 int类型
变量a2的数据类型为 int，但是a2没有声明为指针或引用因此 const属性被去掉, auto被推导为 int
变量a3的数据类型为 const int&，a3被声明为引用因此 const属性被保留，auto关键字被推导为 int类型
变量a4的数据类型为 const int&，a4被声明为引用因此 const属性被保留，auto关键字被推导为 const int类型

#### 不能使用auto情况

1）不能作为函数参数使用。因为只有在函数调用的时候才会给函数参数传递实参，auto要求必须要给修饰的变量赋值，因此二者矛盾。

```C++
int func(auto a, auto b)	// error
{	
    cout << "a: " << a <<", b: " << b << endl;
}
```

2）不能用于类的非静态成员变量的初始化

```C++
class Test
{
    auto v1 = 0;                    // error
    static auto v2 = 0;             // error,类的静态非常量成员不允许在类内部直接初始化
    static const auto v3 = 10;      // ok
}
```

3）不能使用auto关键字定义数组

```C++
int func()
{
    int array[] = {1,2,3,4,5};  // 定义数组
    auto t1 = array;            // ok, t1被推导为 int* 类型
    auto t2[] = array;          // error, auto无法定义数组
    auto t3[] = {1,2,3,4,5};;   // error, auto无法定义数组
}
```

4）无法使用auto推导出模板参数

```C++
template <typename T>
struct Test{}

int func()
{
    Test<double> t;
    Test<auto> t1 = t;           // error, 无法推导出模板类型
    return 0;
}
```

####  建议使用auto情况

1）用于STL的容器遍历

```C++
#include <map>
int main()
{
    map<int, string> person;
    map<int, string>::iterator it = person.begin();
    for (; it != person.end(); ++it)
    {
        // do something
    }
    return 0;
}
```

2）用于泛型编程 模板

在使用模板的时候，很多情况下我们不知道变量应该定义为什么类型，比如下面的代码：

```C++
#include <iostream>
#include <string>
using namespace std;

class T1
{
public:
    static int get()
    {
        return 10;
    }
};

class T2
{
public:
    static string get()
    {
        return "hello, world";
    }
};

template <class A>
void func(void)
{
    auto val = A::get();
    cout << "val: " << val << endl;
}

int main()
{
    func<T1>();
    func<T2>();
    return 0;
}
```



### decltype

在某些情况下，不需要或者不能定义变量，但是希望得到某种类型，这时候就可以使用C++11提供的decltype关键字了，它的作用是在编译器编译的时候推导出一个表达式的类型，语法格式如下：

```C++
decltype (表达式)
```

decltype 是“declare type”的缩写，意思是“声明类型”。decltype的推导是在编译期完成的，它只是用于表达式类型的推导，并不会计算表达式的值。来看一组简单的例子：

```C++
int a = 10;
decltype(a) b = 99;                 // b -> int
decltype(a+3.14) c = 52.13;         // c -> double
decltype(a+b*c) d = 520.1314;       // d -> double
```

#### 表达式为左值

表达式是一个左值，或者被括号( )包围，使用 decltype推导出的是表达式类型的引用（如果有const、volatile限定符不能忽略）。

```C++
#include <iostream>
#include <vector>
using namespace std;

class Test
{
public:
    int num;
};

int main() {
    const Test obj;
    //带有括号的表达式
    decltype(obj.num) a = 0;
    decltype((obj.num)) b = a;
    //加法表达式
    int n = 0, m = 0;
    decltype(n + m) c = 0;
    decltype(n = n + m) d = n;
    return 0;
}
```

obj.num 为类的成员访问表达式，符合场景1，因此 a 的类型为int
obj.num 带有括号，符合场景3，因此b 的类型为 const int&。
n+m 得到一个右值，符合场景1，因此c的类型为 int
n=n+m 得到一个左值 n，符合场景3，因此d的类型为 int&

####  decltype的应用

```C++
#include <list>
#include <iostream>
using namespace std;

template <class T>
class Container
{
public:
    void func(T& c)
    {
        for (m_it = c.begin(); m_it != c.end(); ++m_it)
        {
            cout << *m_it << " ";
        }
        cout << endl;
    }
private:
    decltype(T().begin()) m_it;  // 这里不能确定迭代器类型
};

int main()
{
    const list<int> lst{ 1,2,3,4,5,6,7,8,9 };
    Container<const list<int>> obj;
    obj.func(lst);
    return 0;
}
```

#### 返回类型后置

在泛型编程中，可能需要通过参数的运算来得到返回值的类型，比如下面这个场景：

```C++
#include <iostream>
using namespace std;
// R->返回值类型, T->参数1类型, U->参数2类型
template <typename R, typename T, typename U>
R add(T t, U u)
{
    return t + u;
}

int main()
{
    int x = 520;
    double y = 13.14;
    // auto z = add<decltype(x + y), int, double>(x, y);
    auto z = add<decltype(x + y)>(x, y);	// 简化之后的写法
    cout << "z: " << z << endl;
    return 0;
}
```

关于返回值，从上面的代码可以推断出和表达式 t+u的结果类型是一样的，因此可以通过通过decltype进行推导，关于模板函数的参数t和u可以通过实参自动推导出来，因此在程序中就也可以不写。虽然通过上述方式问题被解决了，但是解决方案有点过于理想化，因为对于调用者来说，是不知道函数内部执行了什么样的处理动作的。

因此如果要想解决这个问题就得直接在 add 函数身上做文章

在C++11中增加了返回类型后置语法，说明白一点就是将decltype和auto结合起来完成返回类型的推导。其语法格式如下:

```C++
// 符号 -> 后边跟随的是函数返回值的类型
auto func(参数1, 参数2, ...) -> decltype(参数表达式)
```

通过对上述返回类型后置语法代码的分析，得到结论：auto 会追踪 decltype() 推导出的类型，因此上边的add()函数可以做如下的修改：

```C++
#include <iostream>
using namespace std;

template <typename T, typename U>
// 返回类型后置语法
auto add(T t, U u) -> decltype(t+u) 
{
    return t + u;
}

int main()
{
    int x = 520;
    double y = 13.14;
    // auto z = add<int, double>(x, y);
    auto z = add(x, y);		// 简化之后的写法
    cout << "z: " << z << endl;
    return 0;
}
```



### 基于范围的for循环

我们在遍历的过程中需要给出容器的两端：开头（begin）和结尾（end），因为这种遍历方式不是基于范围来设计的。在基于范围的for循环中，不需要再传递容器的两端，循环会自动以容器为范围展开，并且循环中也屏蔽掉了迭代器的遍历细节，直接抽取容器中的元素进行运算，使用这种方式进行循环遍历会让编码和维护变得更加简便。

```C++
for (declaration : expression)
{
    // 循环体
}
```

在上面的语法格式中declaration表示遍历声明，在遍历过程中，当前被遍历到的元素会被存储到声明的变量中。expression是要遍历的对象，它可以是表达式、容器、数组、初始化列表等。

**对容器的遍历过程中，如果只是读数据，不允许修改元素的值，可以使用const定义保存元素数据的变量，在定义的时候建议使用const auto &，这样相对于const auto效率要更高一些。**

```C++
#include <iostream>
#include <vector>
using namespace std;

int main(void)
{
    vector<int> t{ 1,2,3,4,5,6 };
    for (const auto& value : t)
    {
        cout << value << " ";
    }

    return 0;
}
```

#### 注：map的遍历

```C++
#include <iostream>
#include <string>
#include <map>
using namespace std;

int main(void)
{
    map<int, string> m{
        {1, "lucy"},{2, "lily"},{3, "tom"}
    };

    // 基于范围的for循环方式
    for (auto& it : m)
    {
        cout << "id: " << it.first << ", name: " << it.second << endl;
    }

    // 普通的for循环方式
    for (auto it = m.begin(); it != m.end(); ++it)
    {
        cout << "id: " << it->first << ", name: " << it->second << endl;
    }

    return 0;
}
```

在上面的例子中使用两种方式对map进行了遍历，通过对比有两点需要注意的事项：

使用普通的for循环方式（基于迭代器）遍历关联性容器， auto自动推导出的是一个迭代器类型，需要使用迭代器的方式取出元素中的键值对（和指针的操作方法相同）：
it->first
it->second
使用基于范围的for循环遍历关联性容器，auto自动推导出的类型是容器中的value_type，相当于一个对组（std::pair）对象，提取键值对的方式如下：
it.first
it.second



##### map插入方式

```C++
//插入
map<int, int> m;
//第一种插入方式
m.insert(pair<int, int>(1, 10));
//第二种插入方式
m.insert(make_pair(2, 20));
//第三种插入方式
m.insert(map<int, int>::value_type(3, 30));
//第四种插入方式
m[4] = 40; 
```



#### 注：set

通过对基于范围的for循环语法的介绍可以得知，在for循环内部声明一个变量的引用就可以修改遍历的表达式中的元素的值，但是这并不适用于所有的情况，对应set容器来说，内部元素都是只读的，这是由容器的特性决定的，因此在for循环中    auto&    会被视为     **const auto &**    。

```C++
#include <iostream>
#include <set>
using namespace std;

int main(void)
{
    set<int> st{ 1,2,3,4,5,6 };
    for (auto &item : st)     //  const auto &   
    {
        cout << item++ << endl;		// error, 不能给常量赋值
    }
    return 0;
}
```



#### 访问次数

基于范围的for循环遍历的对象可以是一个表达式或者容器/数组等。假设我们对一个容器进行遍历，在遍历过程中for循环对这个容器的访问频率是**一次**还是多次呢？我们通过下面的例子验证一下：

```C++
#include <iostream>
#include <vector>
using namespace std;

vector<int> v{ 1,2,3,4,5,6 };
vector<int>& getRange()
{
    cout << "get vector range..." << endl;
    return v;
}

int main(void)
{
    for (auto val : getRange())
    {
        cout << val << " ";
    }
    cout << endl;

    return 0;
}
```

```C++
// 输出结果
get vector range...
1 2 3 4 5 6
```

**从上面的结果中可以看到，不论基于范围的for循环迭代了多少次，函数getRange()只在第一次迭代之前被调用，得到这个容器对象之后就不会再去重新获取这个对象了。**





### lambda表达式

[=]  ：拷贝进来的数据是**只读**属性的     想要修改 要加mutable

![image-20240126105305721](爱编程的大丙C++11新特性.assets/image-20240126105305721.png)



### using 别名

```C++
	using ptr = int (*) (int, int);
	ptr p = [](int x, int y) -> int {
		cout << x + y;
		return x + y;
	};
```

ptr 就是一个别名代表 int (*) (int, int)



### 仿函数

在C++中，**仿函数（Functor）是一个类或结构体**，它实现了函数调用运算符 `operator()`，使得该类的对象可以像函数一样被调用。

```c++
// 仿函数类
class Adder {
public:
    // 重载函数调用运算符
    int operator()(int a, int b) {
        return a + b;
    }
};

int main() {
    // 创建仿函数对象
    Adder add;
    // 使用仿函数调用函数
    int result = add(3, 4);
    return 0;
}
```



### std::function

C++11新增了std::function和std::bind。用于函数的包装以及参数的绑定。可以替代一些**函数指针**，**回调函数**的场景。

#### std::function对象包装器

std::function是可调用对象的包装器，它可以用来用统一的方式来处理函数、函数对象、函数指针，并允许保存和延迟执行它们。比较难理解，可以从代码上深入：

```C++
#include <iostream>
#include <functional>

void func(void)
{
	std::cout << __FUNCTION__ << std::endl;
}

class Foo
{
public:
	static int foo_func(int a)
	{
		std::cout << __FUNCTION__ << " :input param:" << a << std::endl;
		return a;
	}
};
class Bar
{
public:
	int operator()(int a)
	{
		std::cout << __FUNCTION__ << " :input param:" <<a<< std::endl;//
		return a;
	}
};
int main()
{
	std::function<void(void)> fr1 = func;//绑定普通函数
	fr1();
    std::function<int(int)> fr2 = Foo::foo_func;//绑定一个类的静态成员函数
    std::cout << "result:"<< fr2(123) << std::endl;

    Bar bar;
    std::function<int(int)> fr3 = bar;//绑定一个仿函数
    //fr2 = bar;//这里用fr2也可以，因为这两个函数的返回值和参数表是一样的
    std::cout << "result" <<fr3(123) << std::endl;
    return 0;
}
```

注意：代码中__FUNCTION__是预定义标识符，基本功能是实现返回所在函数的名字，便于调试日志打印。

![在这里插入图片描述](https://img-blog.csdnimg.cn/bbe1121caaf54160b4ea0dbc4cf523f6.png)

可以看出使用给std::function赋值上对应的函数返回值和函数参数表，它就可以容纳这一类调用方式的函数，被称为“函数包装器”。如上述的fr2可以容纳Foo::foo_func和bar。
这里可以看出function类似于函数指针的作用，可以保存各种类型的函数地址。

#### std::function做回调函数
```C++
#include <iostream>
#include <functional>

class A
{
	std::function<void(int)> callback_;
public:
	A(const std::function<void(int)>& f) : callback_(f) {}
	void notify(int a)
	{
		callback_(a);
	}
};
class Foo
{
public:
	void operator()(int a)
	{
		std::cout << __FUNCTION__  <<" a:" << a << std::endl;
	}
};
int main()
{
	Foo foo;
	A aa(foo);
	aa.notify(111);
	return 0;
}
```

这里可以看出function可以取代函数指针的作用，可以用function保存函数延迟执行，所有比较适合用在回调函数场景。

### std::bind

std::bind可以将可调用对象和其参数一起绑定，绑定后的结果可以用std::function进行保存。
其中绑定普通函数和绑定成员函数的写法有所不同。

#### bind绑定普通函数

```C++
#include <iostream>
#include <functional>

void input(int x)
{
	std::cout << x << std::endl;
}

int main()
{
	std::function<void(int)> fr = std::bind(input, std::placeholders::_1);
	auto fr1 = std::bind(input, std::placeholders::_1); // 这里用auto接收也行
	fr(2);
	fr1(3);
	return 0;
}
```

其中std::placeholders::_1是一个占位符，表示这个位置将在函数调用时，被传入的第一个参数替代。

##### **占位符的使用方法**

```C++
#include <iostream>
#include <functional>

void input(int x, int y)
{
	std::cout << x << " " << y << std::endl;
}

int main()
{
	std::function<void(int, int)> fr = std::bind(input, std::placeholders::_1, 2);// 这里用auto接收也行
	fr(4, 5);//4 2
	fr = std::bind(input, 2, std::placeholders::_1);
	fr(4, 5);//2 4
	fr = std::bind(input, std::placeholders::_1, std::placeholders::_2);
	fr(4, 5);//4 5
	fr = std::bind(input, std::placeholders::_2, 2);
	fr(4, 5);//5 2
	fr = std::bind(input, 2, std::placeholders::_2);
	fr(4, 5);//2 5
	return 0;
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/c32bc48caab64a9498d1db838d06bc2d.png)

在绑定参数时，可以通过占位符std::placeholders来决定空位参数会属于调用发生时的第几个参数。

#### bind绑定成员函数    成员变量

bind可以绑定成员函数和成员变量。其中绑定成员函数和绑定普通函数时是有一些差别的。

```C++
#include <iostream>
#include <functional>

class MyClass {
public:
	int i_ = 0;
	void foo(int a, int b) {
		std::cout << a << " " << b << std::endl;
	}
};

int main() {
	MyClass obj;
	auto boundFunc = std::bind(&MyClass::foo, &obj, std::placeholders::_1, std::placeholders::_2);//绑定成员函数
	boundFunc(3, 4);
	auto fr_i = std::bind(&MyClass::i_, &obj);//绑定成员变量
	fr_i() = 123;

	return 0;
}
```

当使用 std::bind 绑定成员函数时，需要注意以下几点：

需要使用成员函数的指针或函数对象来进行绑定。对于指针，需要使用 & 取址符号获取成员函数的地址。
需要提供对象的指针（或引用）作为第一个参数，以便在调用时正确地调用成员函数。
可以看到绑定普通函数时是不需要提供对象的指针或引用作为参数。





## 3. 通用性能的提升

 ### constexpr

<img src="爱编程的大丙C++11新特性.assets/image-20240126145825437.png" alt="image-20240126145825437" style="zoom:80%;" />
