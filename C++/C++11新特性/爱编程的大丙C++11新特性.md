# 爱编程的大丙C++11新特性

https://subingwen.cn/cplusplus/

## 1. 稳定性和兼容性



### 原始字面量

定义方式为：R “xxx(原始字符串)xxx”      其中（）两边的字符串可以省略。

强调一个细节：在R “xxx(raw string)xxx” 中，原始字符串必须用括号（）括起来，括号的前后可以加其他字符串，所加的字符串会被忽略，并且加的字符串必须在括号两边同时出现。

原始字面量R可以直接表示字符串的实际含义，而不需要额外对字符串做转义或连接等操作。

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string str = "D:\hello\world\test.text";
    cout << str << endl;
    string str1 = "D:\\hello\\world\\test.text";
    cout << str1 << endl;
    string str2 = R"(D:\hello\world\test.text)";
    cout << str2 << endl;
    return 0;
}
```

```C++
输出的结果为:

1 D:helloworld    est.text
2 D:\hello\world\test.text
3 D:\hello\world\test.text
```

在D:\hello\world\test.text中\h和\w转义失败，对应的字符会原样输出
在D:\\hello\\world\\test.text中路径的间隔符为\但是这个字符又是转义字符，因此需要使用转义字符将其转义，最终才能得到一个没有特殊含义的普通字符\
在R"(D:\hello\world\test.text)"使用了原始字面量R（）中的内容就是描述路径的原始字符串，无需做任何处理



### long long 整形

```C++
long long - 对应类型的数值可以使用 LL (大写) 或者 ll (小写) 后缀

C++
1 long long num1 = 123456789LL;
2 long long num2 = 123456789ll;
```

```C++

unsigned long long - 对应类型的数值可以使用 ULL (大写) 或者 ull (小写) 或者 Ull、uLL (等大小写混合)后缀

C++
1 unsigned long long num1 = 123456789ULL;
2 unsigned long long num2 = 123456789ull;
3 unsigned long long num3 = 123456789uLL;
4 unsigned long long num4 = 123456789Ull;
```

![image-20240118152141559](爱编程的大丙C++11新特性.assets/image-20240118152141559.png)

![image-20240118153603495](爱编程的大丙C++11新特性.assets/image-20240118153603495.png)



### 类成员的快速初始化

```C++
class Test
{
private:
    int a = 9;     // C++11 对非静态成员变量进行初始化，在初始化的时候可以使用等号 = 也可以使用花括号 {}
    int b = {5};   // C++98 非静态成员变量的初始化则必须在构造函数中进行。
    int c{12};
    double array[4] = { 3.14, 3.15, 3.16, 3.17};
    double array1[4] { 3.14, 3.15, 3.16, 3.17 };
    string s1("hello");     // error    不能使用小括号() 初始化对象，应该使用花括号{}
    string s2{ "hello, world" };
};
```

同时在类内部对非静态成员变量就地初始化和在初始化列表中进行初始化会怎么样呢？

```C++
class Init
{
public:
    Init(int x, int y, int z) :a(x), b(y), c(z) {}

    int a = 1;
    int b = 2;
    int c = 3;
};

int main()
{
    Init tmp(10, 20, 30);
    cout << "a: " << tmp.a << ", b: " << tmp.b << ", c: " << tmp.c << endl;
    return 0;
}
```

结果：a: 10, b: 20, c: 30

我们可以从函数的打印输出中看到，在类内部就地初始化和初始化列表并不冲突（程序可以正常运行）。程序员可以为同一成员变量既在类内部就地初始化，又在初始化列表中进行初始化，只不过初始化列表总是看起来后作用于非静态成员。也就是说，通过初始化列表指定的值会覆盖就地初始化时指定的值。

### final和override

