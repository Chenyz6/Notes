# 牛客C++专项练习



## sizeof和strlen

 数组的sizeof值等于数组所占用的内存字节数。
1）当字符数组表示字符串时，其sizeof值将’/0’计算进去。
2）当数组为形参时，其sizeof值相当于指针的sizeof值

strlen是遇到结束符则停止，所以 strlen出来的结果是不包含\0的



**sizeof**

**字符串*才*包含"\0"    所以多一个**

**数组就是正常的长度**



## ->和++ 优先级   <<  ^

成员选择符->优先级比前置++、后置++都要高。

<<的优先级高于^的优先级

![image-20221110113134240](牛客C++专项练习.assets/image-20221110113134240.png)

![image-20221110113222362](牛客C++专项练习.assets/image-20221110113222362.png)



**加减乘除   移位    位     逻辑操作**



## 继承派生方式

![image-20221103101835589](牛客C++专项练习.assets/image-20221103101835589.png)

在哪种派生方式中，派生类可以访问基类中的protected成员（ ）

public和private
public和protected
protected和private
**public、protected、private均可**



## 括号表达式

括号表达式计算顺序是从左到右，然后整个表达式返回的是最右边表达式的值

已知int i=0, j=1, k=2;，则逻辑表达式      ++i||- -j&&++k   值为（1）



&&	 全真为真

||	   全假为假



## 静态局部变量

函数中的静态局部变量默认为0



## 容器分配到另一个容器

需要提前给目标容器分配空间

merge（）   和      transform（）     和    copy（）  和    set_intersection（）  和   set_union（）



## \ 不是完整的字符

‘\’不是字符

‘\xff’是十六进制表示的字符

'\O00'1到3位表示的八进制字符

NULL 本质是字符'\0'，ASCII码为0



## string函数assign（）

assign（） 在分配的时候 **必须是空的字符串** 要不然编译不通过

拼接字符串使用append（）



## 容器区别

1）只有set和map  有 查找find和统计count

2）只有set和map   erase可以删除值为多少的元素

3）对于随机访问的迭代器的容器，都可以利用sort算法直接对其进行排序      string     vector     deque



## 对组的创建

void test01()
{
	pair<string, int> p(string("Tom"), 20);
	cout << "姓名： " <<  p.first << " 年龄： " << p.second << endl;



​    pair<string, int> p2 = make_pair("Jerry", 10);
​    cout << "姓名： " << p2.first << " 年龄： " << p2.second << endl;

}



## 用new开辟的数组不要用sizeof

new开辟的时候已经知道大小了



## 函数重写 重载

链接：https://www.nowcoder.com/questionTerminal/2118aa97672a4575a661c1faef7142d4

**函数重载**(Overload) :

 同类同名不同参方法
 发生在同一个类中。
 方法名相同、参数列表不相同。
 **和返回值没有关系**。



 **函数重写**（Override）：

 在子类中和父类相同声明的方法
 发生在子父类中，必须有继承关系。
 返回值类型相同、方法名、参数列表相同。
 子父类中的方法一模一样。



## 指向函数指针定义方式

返回类型  (*指针名）  (函数参数列表)  ，例如 void （*p）（int）是指向一个返回值为void 参数为int类型的函数

**对于指向成员函数的指针略有不同：**

**普通成员变量：**返回类型 （类名::*指针名）=

**静态成员变量：**返回类型 （*指针名）=

需要注意，***初始化静态成员变量要在类外初始化，不能在声明时直接赋值**。*

并且，**调用静态成员变量的时候，不需要加对象名，直接\*指针，**

另外，**因为优先级的原因，调用成员函数指针的时候括号不能少**。





## erase（）特点

erase（）函数的特点就是删除当前的元素，并自动指向下一个元素。





## 实例化对象

若一个类没有默认构造函数，那么我们在实例化该类对象时就需要传参对其进行初始化，所以实例化没有默认构造函数的类对象时必须使用初始化列表对其进行初始化。





## Map容器可以通过[键值]  直接来查找实值

#include <map>
map<char, int> symbolValues = {
	{ 'I', 1 },
	{ 'V', 5 },
	{ 'X', 10 },
	{ 'L', 50 },
	{ 'C', 100 },
	{ 'D', 500 },
	{ 'M', 1000 },
};

int main()
{
	int value = symbolValues['M'];
	cout << value << endl;
	system("pause");
	return 0;
}



## 二维数组问题

`#include <stdio.h>
int main() { 
    int  intArray[] = {1, 2, 3, 4, 5}; 
    int  *p = (int *)(&intArray+1); 
    printf("%d,%d",*(intArray+1),*(p-1)); 
    return 0; 
}`



int  *p = (int *)(&intArray+1);
intArray：是数组的首地址，
&intArray：就是存放这个数组首地址的地址,可用int (*)[5]的指针保存，
&intArray+1：相当于int (*)[5]这个指针的指针偏移，偏移量是指向元素的大小*1，（比如double *p，p+1的偏移量就是一个double的大小*1）
(int *)(&intArray+1)：相当于把偏移后的地址（也是一个int[5]）强转给p保存；
可得p指的是数组intArray结尾的下个地址，用二维数组理解的话就是intArray是第一个int[5]，即int[0][5]，p指向的是int[1][5]

*(p-1)就是intArray[5]向前一位即intArray[4]的值





## volatile关键字

volatile三个特性：**易变性；不可优化性；顺序性**。

A易变性：不从寄存器读取，而直接读取内存

B不可优化性：告诉编译器不要对volatile变量进行优化

C，D都涉及顺序性，volatile只保证编译器不对volatile变量之间的顺序进行改变

如果一个基本变量被volatile修饰，编译器将不会把它保存到寄存器中，而是每一次都去访问内存中实际保存该变量的位置上 

优化器在用到volatile变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份

![image-20230412102114616](牛客C++专项练习.assets/image-20230412102114616.png)





## malloc/free和new/delete的本质区别

1.malloc/free 是C/C++语言的标准库函数，new/delete是C++的运算符

**2.new 能自动分配空间大小**

3.对于用户自定义的对象而言，用malloc/free**无法满足动态管理对象**的要求，对象在创建的时候会自动调用构造函数，对象在消亡之前自动执行析构函数由于malloc/free是库函数而不是运算符，不在编译器的控制范围，不能把构造函数和析构函数的任务强加于malloc/free 。一次C++需要一个能够对对象完成动态分配内存和初始化工作的运算符new，以及一个释放内存的运算符 delete。简单来说就是new/delete能完成跟家详细的对内存的操作，而malloc/ free不能。

**new返回的是所分配类型对象的指针，malloc返回的是void***





## 内联函数

函数调用在执行时，首先要在栈中为形参和局部变量分配存储空间，然后还要将实参的值复制给形参，接下来还要将函数的返回地址（该地址指明了函数执行结束后，程序应该回到哪里继续执行）放入栈中，最后才跳转到函数内部执行。这个过程是要耗费时间的。

另外，函数执行 return 语句返回时，需要从栈中回收形参和局部变量占用的存储空间，然后从栈中取出返回地址，再跳转到该地址继续执行，这个过程也要耗费时间。

总之，使用函数调用语句和直接把函数中的代码重新抄写一遍相比，节省了人力，但是带来了程序运行时间上的额外开销。

**内联函数和普通函数的区别在于：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处，就像整个函数体在调用处被重写了一遍一样。**

有了内联函数，就能像调用一个函数那样方便地重复使用一段代码，而不需要付出执行函数调用的额外开销。很显然，使用内联函数会使最终可执行程序的体积增加。以时间换取空间，或增加空间消耗来节省时间，这是计算机学科中常用的方法。

内联函数中的代码应该只是很简单、执行很快的几条语句。如果一个函数较为复杂，它执行的时间可能上万倍于函数调用的额外开销，那么将其作为内联函数处理的结果是付出让代码体积增加不少的代价，却只使速度提高了万分之一，这显然是不划算的。





## 虚析构和纯虚析构

多态使用时，如果子类中有属性开辟到堆区，那么***父类指针在释放时无法调用到子类的析构代码***

***父类指针在析构的时候 不会调用子类中析构函数 导致子类如果有堆区属性，出现内存泄露***

解决方式：将父类中的析构函数改为**虚析构**或者**纯虚析构**



虚析构和纯虚析构共性：

* 可以解决父类指针释放子类对象
* 都需要有具体的函数实现

虚析构和纯虚析构区别：

* 如果是纯**虚析构**，该类属于抽象类，**无法实例化对象**



虚析构语法：

`virtual ~类名(){}`

***纯虚析构语法：***

***` virtual ~类名() = 0;`***

***`类名::~类名(){}`    必须要有实现***

**如果有了纯虚析构之后，这个类也属于抽象类，无法实例化对象



**纯虚析构函数必须要有实现！！！！！！！！！！！！**



总结：

​	1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象

​	2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构

​	3. ***拥有纯虚析构函数的类也属于抽象类  这个类无法实例化对象***



## 函数重写

函数返回值类型

函数名

参数列表   都相同





## extern

![image-20221129172004463](牛客C++专项练习.assets/image-20221129172004463.png)

extern "C"指令中的C，表示的一种编译和连接规约，而不是一种语言。C表示符合C语言的编译和连接规约的任何语言，如Fortran、assembler等





## 多态原理-虚函数

![image-20221130134413189](牛客C++专项练习.assets/image-20221130134413189.png)







## 函数重新定义 重载

函数不能重新定义，只能重载，除非换作用域（那也不能叫重新定义）；

函数可以被重载而不能重新定义，重载后函数具有不同的形参，原有定义并不失效；







## lambda 表达式

lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda 表达式的语法形式可简单归纳如下：

[ capture ] ( params ) opt -> ret { body; };

其中 capture 是捕获列表，params 是参数表，opt 是函数选项，ret 是返回值类型，body是函数体。

因此，一个完整的 lambda 表达式看起来像这样：

```
auto f = [](int a) -> int { return a + 1; };std::cout << f(1) << std::endl;  // 输出: 2
```

可以看到，上面通过一行代码定义了一个小小的功能闭包，用来将输入加 1 并返回。

在 C++11 中，lambda 表达式的返回值是通过前面介绍的《[C++返回值类型后置](http://c.biancheng.net/view/3727.html)》语法来定义的。其实很多时候，lambda 表达式的返回值是非常明显的，比如这个例子。因此，C++11 中允许省略 lambda 表达式的返回值定义：

auto f = [](int a){ return a + 1; };

这样编译器就会根据 return 语句自动推导出返回值类型。

需要注意的是，初始化列表不能用于返回值的自动推导：

auto x1 = [](int i){ return i; }; // OK: return type is int
auto x2 = [](){ return { 1, 2 }; }; // error: 无法推导出返回值类型

这时我们需要显式给出具体的返回值类型。

另外，lambda 表达式在没有参数列表时，参数列表是可以省略的。因此像下面的写法都是正确的：

auto f1 = [](){ return 1; };
auto f2 = []{ return 1; }; // 省略空参数表





使用 lambda 表达式捕获列表

lambda 表达式还可以通过捕获列表捕获一定范围内的变量：

- [] 不捕获任何变量。
- [&] 捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。
- [=] 捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）。
- [=，&foo] 按值捕获外部作用域中所有变量，并按引用捕获 foo 变量。
- [bar] 按值捕获 bar 变量，同时不捕获其他变量。
- [this] 捕获当前类中的 this [指针](http://c.biancheng.net/c/80/)，让 lambda 表达式拥有和当前类成员函数同样的访问权限。如果已经使用了 & 或者 =，就默认添加此选项。捕获 this 的目的是可以在 lamda 中使用当前类的成员函数和成员变量。



## throw（抛出异常）

![image-20221201180459061](牛客C++专项练习.assets/image-20221201180459061.png)





## 回调函数

回调函数就是一个通过函数指针调用的函数。
如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。
回调函数不是由该函数的实现方法直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。



this指针

核心就是类成员函数需要this指针访问函数，而全局或者静态函数不需要this指针。
简言之，类的成员函数需要隐含的this指针 而回调函数没有办法提供。





## 数组的定义

![image-20221201200004413](牛客C++专项练习.assets/image-20221201200004413.png)







## 虚函数

链接：https://www.nowcoder.com/questionTerminal/06198cda7311404698a6d10d3dabbdf2
来源：牛客网



以关键字virtual的成员函数称为虚函数，主要是用于运行时多态，也就是动态绑定。 

  虚函数必须是类的成员函数，不能使友元函数、也不能是构造函数【原因：因为建立一个派生类对象时，必须从类层次的根开始，沿着继承路径逐个调用基类的构造函数，直到自己的构造函数，不能选择性的调用构造函数】 

  不能将虚函数说明为全局函数，也不能说明为static静态成员函数。因为虚函数的动态绑定必须在类的层次依靠this指针实现。 

  再添加一点： 

  虚函数的重载特性：一个派生类中定义基类的虚函数是函数重载的一种特殊形式。 

  重载一般的函数：函数的返回类型和参数的个数、类型可以不同，仅要求函数名相同； 

  而重载虚函数：要求函数名、返回类型、参数个数、参数类型和顺序都完全相同。 

  

  纯虚函数：是在基类中说明的虚函数，它在基类中没有是在定义，要求所有派生类都必须定义自己的版本。 

  纯虚函数的定义形式：virtual 类型  函数名(参数表)=0，该函数赋值为0，表示没有实现定义。在基类中定义为0，在派生类中实现各自的版本。 

  

  纯虚函数与抽象类的关系： 

  抽象类中至少有一个纯虚函数。 

  如果抽象类中的派生类没有为基类的纯虚函数定义实现版本，那么它仍然是抽象类，相反，定义了纯虚函数的实现版本的派生类称为具体类。 

  抽象类在C++中有以下特点： 

1. ​    抽象类只能作为其他类的基类；    
2. ​    抽象类不能建立对象；    
3. ​    抽象类不能用作参数类型、参数返回类型或显示类型转换。





## 条件运算符优先级  大于  赋值运算符





##  复试题

![image-20221205141337175](牛客C++专项练习.assets/image-20221205141337175.png)





## 迭代器失效

vector是顺序储存，器插入元素后会使后面的元素向后移，所以会使指向后面的元素迭代器失效

map不是顺序存储插入删除元素不会引起其他元素的位置移动，所以只有删除元素时对指向删除元素的迭代器有影响





##   \ " 

\ " 代表一个双引号"符号

"\ "%s\ "\n" 输出 "s[6]"换行。



## “烫” “屯”

微软的 VC 编译器会将未初始化的栈空间以 16 进制的 0xCC 填充，而未初始化的堆空间使用 0xCD 填充，而 0xCCCC 和 0xCDCD 在中文的 GB2312 编码中刚好对应“烫”和“屯”字。

对于栈中内存如果没有初始化，则会出现“烫烫烫烫烫烫”。

对于堆中内存如果没有初始化，则会出现“屯屯屯屯屯”



## 内存泄露！！！

![image-20221227100108350](C:\Users\10799\AppData\Roaming\Typora\typora-user-images\image-20221227100108350.png)

**1.main函数里的s没有初始化就在fun函数里使用s，编译器会报警告，运行时会报错（局部变量未初始化）。答案选D。** 

**2.就算s初始化了，在fun函数里，局部变量t的大小为7，而strcpy函数会复制example末尾的\0 ，所以example+'\0'一共8个字节空间，会溢出，程序会崩溃。** 

**3.就算局部变量t的大小足够大，在fun函数运行结束后，局部变量t的内存空间会被释放掉，此时s成为野指针；返回main函数后，也不会输出example。**





## 类占用内存空间

链接：https://www.nowcoder.com/questionTerminal/217a3f28fb3c410fa9e7aaafebe7e468
来源：牛客网

**A. 类所占大小由虚函数、所有非静态数据成员大小、对其所占字节数决定。 A错误** 

B. 空类大小为一个字节。B正确 

C. 无论基类还是派生类都会共用一个虚函数表，只会占用一个虚表指针大小。C正确 

D. 派生对象的大小才为基类存储空间+派生类特有的**非static数据**成员的空间，D选项共有几点错误：1.派生对象才为两个相加；2.派生类必须为**非static数据。**



## strcpy

链接：https://www.nowcoder.com/questionTerminal/52f4ddcb0b7a4325983d5b5828659335

![image-20230109161406058](牛客C++专项练习.assets/image-20230109161406058.png)

执行strcpy(ccString1,"No"); ，ccString1变为"No\0Page Fault??"，

会将字符串的结束符'\0'放入，所以比较时返回false，

执行cout << ccString1; 输出时遇到结束符'\0'就结束，只输出“NO”



strcmp**若前大于后，则返回大于零的数；否则，则返回小于零的数**





## 数组声明

![image-20230109161622991](牛客C++专项练习.assets/image-20230109161622991.png)





## 解释型编译型语言

**编译型语言：**

C/C++  

GO语言 

**解释型语言：**

JAVA

JAVAScript

C#

python





## 创建对象

![image-20230113233620643](牛客C++专项练习.assets/image-20230113233620643.png)

A       Qiniuome a();是函数声明.      Qiniuome b(2)和 Qiniuome c[3]创建总共4个;      Qiniuome &ra = b和 Qiniuome *pA = c是指针和引用,不会创建对象       Qiniuome *p = new Qiniuome (4);会创建一个



## cin是istream的类对象 


cin表示标准输入的istream对象

istream的常见成员函数有：**istream::getline() 函数，** **istream::ignore() 函数，** **istream::get() 函数等**



## const` `int` `* ``const` `p = &x;

![image-20230113233833669](牛客C++专项练习.assets/image-20230113233833669.png)

链接：https://www.nowcoder.com/questionTerminal/d254c8b7d83b40869fb1deac913e2581
来源：牛客网

答案:ABD
A. `const int * const p = &x;`中指针p及p指向的int类型数据都被const修饰，即`*p`与`p`都为const属性无法修改

- 编译器报错`error: assignment of read-only location ‘*(const int*)p’ *p = 1;`
- 故`* p =1;`语法错误

B. `const int &q=x;`是指向常量的引用，使用时必须初始化，而且初始化后，引用值不可以改变,引用的常量也不能改变

- 注意 只是修饰引用`q`,`x`不受影响
- 编译器报错`error: increment of read-only reference ‘q’ q++;`
- 故`q++;`语法错误

C. `int const *next=&x;`中`const`修饰整型数 int即`*next`

- 注意 同样只是修饰`*next`,`x`仍然是变量
- 指针变量`next`没有被const修饰因此可以被`next++`改变,语法正确

D. `const int *j=&x;`中`const int *`同`int const *`const修饰`*j`

- 编译器报错`error: increment of read-only location ‘* j’ (*j)++;`
- `(*j)`为const属性无法修改,故语法错误



![image-20230310100646382](牛客C++专项练习.assets/image-20230310100646382.png)



## return返回值

return只能返回一个值



## 循环队列

![image-20230205112022124](牛客C++专项练习.assets/image-20230205112022124.png)

![image-20230205112450676](牛客C++专项练习.assets/image-20230205112450676.png)



## 字符数组问题

![image-20230205112840060](牛客C++专项练习.assets/image-20230205112840060.png)

答案解析：n = strlen(x)，此时n=4，因为x指向y数组，所以x[4]就是y[4]='\0',那么*x=x[n]就是把x指向的字符串首元素改为'\0'，x++之后x指向第二个字符t，所以第一个输出x=tse，而y遇到第一个字符就是'\0'，所以结束，y输出为空



## 字节对齐

`class A{
  virtual void func(){
      cout<<"func"<<endl;
  }  
    
  float f;
  char p;
  int adf[3];
};`

链接：https://www.nowcoder.com/questionTerminal/2c718d2394714c169d84b1933d0d4b4d?
来源：牛客网

假设是在32bit系统下，指针大小为4字节。 

  类A中存在虚函数，因此在对象的内存空间中，首先有1个指针指向虚函数表（VTABLE），指针占4字节； 

  float f;占4字节； 

  char p;占1字节，但是由于内存对齐，下一个变量相对于对象起始位置的偏移量得是4的整数倍，所以补3个字节； 

  int adf[3];占3*sizeof(int)=12个字节。 

  一共占24个字节。





## 创建对象构造和析构

![image-20230210112602988](牛客C++专项练习.assets/image-20230210112602988.png)

成员 n 是类 cla 的静态成员，静态成员默认初始化为0。new cla对象时会调用构造函数，n 变成1。delete 时调用析构函数，n 变成0。因此调用 get_n 后输出0。



## 多线程 原子操作

![image-20230210112745835](牛客C++专项练习.assets/image-20230210112745835.png)



## 指针数组 数组指针

![image-20230210113439050](牛客C++专项练习.assets/image-20230210113439050.png)

**例：int (*p)[10]; p即为指向数组的指针，又称数组指针。**



## 结构体变量

![image-20230211175403279](牛客C++专项练习.assets/image-20230211175403279.png)

`链接：https://www.nowcoder.com/questionTerminal/0287f97708464f6ca2a42f759ca64145?
来源：牛客网

```
struct color c1
{    int red;
    int green;
    int blue;
};
（color c1）  为结构体名，c1只是名称的一部分，并非结构体变量名。
```

`



## 字符串函数

![image-20230211175650847](牛客C++专项练习.assets/image-20230211175650847.png)





## 内联函数注意事项 incline

链接：https://www.nowcoder.com/questionTerminal/cc0b107d247a4090bd232a6caad784be?
来源：牛客网

使用内联函数的时候要注意： 

1. 递归函数不能定义为内联函数  
2. 内联函数一般适合于不存在while和switch等复杂的结构且只有1~5条语句的小函数上，否则编译系统将该函数视为普通函数。 
3. 内联函数只能先定义后使用，否则编译系统也会把它认为是普通函数。  
4. 对内联函数不能进行异常的接口声明。



## C++中空类编译器产生4个成员函数

默认的无参构造函数

默认的析构函数

默认的拷贝构造函数

默认赋值函数

![image-20230228203655577](牛客C++专项练习.assets/image-20230228203655577.png)



## 宏定义

![image-20230228203925024](牛客C++专项练习.assets/image-20230228203925024.png)

链接：https://www.nowcoder.com/questionTerminal/761efe02600847a9b260f1001a541ce6?
来源：牛客网



\##是一种分隔连接方式，它的作用是**先分隔，然后进行强制连接**   

  “name”和第一个“”之间被分隔了，所以预处理器会把name## _ ##type##type解释成4段：“**name**”、“”、“**type**”以及“**_type**”，name和type会被替换，而_type不会被替换



![image-20230301095545889](牛客C++专项练习.assets/image-20230301095545889.png)

![image-20230301095618420](牛客C++专项练习.assets/image-20230301095618420.png)



## setw()   #include<iomanip.h>

![image-20230301151331022](牛客C++专项练习.assets/image-20230301151331022.png)



## 类成员默认是private 继承默认也是private

struct 成员默认是public 继承默认也是public



## calloc

![image-20230303155544366](牛客C++专项练习.assets/image-20230303155544366.png)



## 字符串赋值给数组  ×

char *str; str = "Hello";**是合法的，**

char str[]; str = "Hello";**是非法的，数组名是常量，无法赋值**



## 内存分配

![image-20230303163042685](牛客C++专项练习.assets/image-20230303163042685.png)

链接：https://www.nowcoder.com/questionTerminal/9e9e1e149c3b4801b56b6d6a6a2fc8bb?
来源：牛客网

对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制

**对于栈来讲，生长方向是向下的，也就是向着内存地址减小的方向；对于堆来讲，它的生长方向是向上的，是向着内存地址增加的方向增长。**

对于堆来讲，频繁的 new/delete 势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题



## 构造函数

当定义了带参数的构造方法，系统默认的不带参数的构造方法就**不存在**了

![image-20230306155622485](牛客C++专项练习.assets/image-20230306155622485.png)





## DWORD

![image-20230306195624293](牛客C++专项练习.assets/image-20230306195624293.png)



## puts putchar

![image-20230308100236862](牛客C++专项练习.assets/image-20230308100236862.png)

链接：https://www.nowcoder.com/questionTerminal/70fc291ff7444e67a04e2ebe73176e0b?
来源：牛客网

**putchar只能输出单个字符，puts参数只能传一个**

printf("格式控制字符串"， 输出列表)；     如：printf("%s", string); 

putchar（字符数据）；  如：char   a_c=‘h’；putchar（a_c）； 

puts（字符串）；       如：puts（“hello girl”）；



## 字符数组赋值

![image-20230308101024405](牛客C++专项练习.assets/image-20230308101024405.png)



## 运算符重载

链接：https://www.nowcoder.com/questionTerminal/f9929869e23e4e2e8e6631627fba31af?
来源：牛客网



除了**类属关系运算符"."**、**成员指针运算符".\*"**、**作用域运算符"::"**、**sizeof运算符**和**三目运算符"?:"**以外，C++中的所有运算符都可以重载 

但是=、()、[]、->这四个不能重载为类的友元函数。



凡是带  . 点 的都不能重载，还有一个例外，sizeof



## final

final用来修饰类，让该类不能被继承，理解：使得该类终结！
final用来修饰类的虚函数，使得该虚函数在子类中，不能被重写，理解：使得该功能终结！



## override

![image-20230310100238984](牛客C++专项练习.assets/image-20230310100238984.png)

![image-20230310100438002](牛客C++专项练习.assets/image-20230310100438002.png)



## 宏定义
![在这里插入图片描述](https://img-blog.csdnimg.cn/a95ee5b37e4f47469db9dcbe36b0f762.png)

替换为：sum = m+n+m+n*k = 10



## Struct 和 Class 区别
在C++中，来自class的继承默认按照private继承处理，来自struct的继承默认按照public继承处理
class的成员默认是private权限，struct默认是public权限
c里面的struct是变量的聚合体，struct可以有函数
c++的struct可有构造和析构函数



## ％x是以16进制输出 
![在这里插入图片描述](https://img-blog.csdnimg.cn/8ff56f75e1944a518ee5ae63b8317246.png)



## 变量在内存存放的地点

```cpp
#include<iostream>
using namespace std;
int main(void)
{
    char str1[] = "hello world";   //存放在栈中的数组
    char str2[] = "hello world";   //存放在栈中的数组

    const char str3[] = "hello world";  //存放在栈中的字符串常量
    const char str4[] = "hello world";  //存放在栈中的字符串常量

    const char* pstring1 = "hello world";   //本身在栈中，指向常量的指针
    const char* pstring2 = "hello world";   //本身在栈中，指向常量的指针     //显然二者所指向的地址一致
}

```
链接：https://www.nowcoder.com/questionTerminal/90002c0cacd94010bda7a22d64faf22d?
来源：牛客网

char *str和char str[]的区别：
char *str = "hello"; //str指向字符串常量"hello"的首地址,str存放在栈上，"hello"保存在文字常量区。通过指针**只能访问字符串常量，不可以改变它**
char str[] = "hello"; //数组名str也是指向字符串的首地址，str，"hello"都存放在栈上。可以通过指针去访问和修改数组内容

一个由C/C++编译的程序占用的内存分为以下几个部分
 1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
 2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分    配方式倒是类似于链表，呵呵。
 3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放
 4、文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放
 5、程序代码区—存放函数体的二进制代码。



## 对象的创建
链接：https://www.nowcoder.com/questionTerminal/0dc754158944469b959135ea3e1fdeb0
来源：牛客网

CSomething a()；// 没有创建对象，这里不是使用默认构造函数，而是定义了一个函数，在C++ Primer393页中有说明。
CSomething b(2);//使用一个参数的构造函数，创建了一个对象。
CSomething c[3];//使用无参构造函数，创建了3个对象。
CSomething &ra=b;//ra引用b，没有创建新对象。
CSomething d=b;//使用拷贝构造函数，创建了一个新的对象d。
CSomething *pA = c;//创建指针，指向对象c，没有构造新对象。
CSomething *p = new CSomething(4);//新建一个对象。





## argc argv

![image-20230412113357283](牛客C++专项练习.assets/image-20230412113357283.png)



## 运算顺序

先进行四则运算，然后移位运算，最后位运算 

![image-20230413180225825](牛客C++专项练习.assets/image-20230413180225825.png)



## 绝不重新定义继承而来的缺省参数值

![image-20230413180440748](牛客C++专项练习.assets/image-20230413180440748.png)

![image-20230413180546807](牛客C++专项练习.assets/image-20230413180546807.png)



## switch语句后的控制表达式

switch语句后的控制表达式只能是short、char、int、long整数类型和枚举类型，

不能是float，double和boolean类型



## else总是与它最上面的最近的if匹配    ×

![image-20230415101021090](牛客C++专项练习.assets/image-20230415101021090.png)



## 构造函数不能为const函数

const函数不改变成员变量，而构造函数意义在于初始化





## 赋值运算符是从右往左计算的

赋值运算符是从右往左计算的，返回值即等号左边对象的引用。

简单赋值的优先级是低于加法优先级的

 所以a=b=c计算顺序是(a=(b=c))，(b=c)运算结果为b的引用，而b已经被赋值为c，所以后面a的值等于c。 

**a=b+c=3的计算顺序为(a=(b+c=3))，b+c的运算结果是一个右值，不能被赋值为3** 。





## 构造函数的创建

![image-20230421172112993](牛客C++专项练习.assets/image-20230421172112993.png)

A 选项由于 x 在 基类 CBase 类中是私有的，所以派生类 CDerive 中无法直接访问。
B 选项正确。
C 选项调用了构造函数 CDerive(b)，而 CDerive 类中没有一个参数的构造函数。
D 选项问题同 A 选项。





## 类型安全

类型安全就是说，如果两个类型直接要相互转换，必须要显示的转换，不能偷偷摸摸的只用一个等于号就隐式转换了 

MFC 中 CString 是类型安全的类



## malloc calloc realloc new

![image-20230421172429752](牛客C++专项练习.assets/image-20230421172429752.png)



## C++17 vector      ------（） {} 区分

链接：https://www.nowcoder.com/questionTerminal/65e8edcb3cce4911b374500246d91d97?#jsEditorModuleBody
来源：牛客网

![image-20230429180214072](牛客C++专项练习.assets/image-20230429180214072.png)

![image-20230429180155082](牛客C++专项练习.assets/image-20230429180155082.png)

对于本题目，我认为考察得是对于()和{}的区分，vector本质上还是数组，

{}所框起来的是数据内容，是可以赋值给vector的，想想数组的初始化是不是经常采用这种方式呢

()则是对于数据的结构进行限定，这是vector特有的。所以()是不能对vector来进行赋值的。

![image-20230429180435097](牛客C++专项练习.assets/image-20230429180435097.png)



## 类对象的创建

![image-20230429180837361](牛客C++专项练习.assets/image-20230429180837361.png)

链接：https://www.nowcoder.com/questionTerminal/7f4edb9f75134da4b1958613d1b93bd1?#jsEditorModuleBody
来源：牛客网

程序运行结果为DDDDD说明调用了5次析构函数，所以需要创建5个对象，D* p=new D[2]创建了两个对象D，那么对象数据 D d[]需要创建3个对象D因此排除 选项C，选项的D的初始化方式错误、A、B是对象数组的两种初始化方式，正确



## 构造函数可以重载

![image-20230503160435638](牛客C++专项练习.assets/image-20230503160435638.png)



## 迭代器

![image-20230503160553489](牛客C++专项练习.assets/image-20230503160553489.png)

迭代器可以看成一个指针，指针有==，判断是否相等，指针有取值*,指针有自加++,指针没有左移  



## 对类内成员初始化

![image-20230504095215618](牛客C++专项练习.assets/image-20230504095215618.png)



## char类型范围   -128~127

![image-20230504095825447](牛客C++专项练习.assets/image-20230504095825447.png)

其实这道题想要考察的是char型的表示范围：-128~127。num永远都到不了255。 

但是题中num的初值设为0，怎么自加都是0，题目变得更简单了。如果初值num=1，这道题还是死循环。 

![image-20230504095957947](牛客C++专项练习.assets/image-20230504095957947.png)



## 64位字节对齐

![image-20230504100625677](牛客C++专项练习.assets/image-20230504100625677.png)

字节对齐的三个准则：

1结构体变量的首地址能够被其最宽基本类型成员的大小所整除；

2 结构体每个成员相对于结构体首地址的偏移量都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节；

3结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。 

再来看这道题： 

a占一个字节（注：地址为[0]）， 补齐之后占8个字节

d作为64位指针占8个字节（注1：32位占四个字节，p也一样）（注2：根据上面的准则2，d的偏移量要为8的整数倍，所以d的地址为[8]-[15]，而非[1]-[8]，下同），

b占了4个字节（注：地址为[16][19]），

c指定为16为，占了两个字节（注：地址为[20,21]）,

e占8个字节，（同d的分析一样，e的地址应该为[24][31]），

所以A的答案应该是8，B的答案是32，C正确，D的答案为8。

![image-20230505094151715](牛客C++专项练习.assets/image-20230505094151715.png)



## 递增运算符重载 前置++和后置++

![image-20230504101020879](牛客C++专项练习.assets/image-20230504101020879.png)

（int）  使用占位符来实现函数重载



## 类的初始化

A：静态函数属于类本身，不与类绑定，因此不能用this指针。A选项正确。 

B：在类定义时，无法使用构造函数，因而无法完成对象的初始化

C：一般成员变量需要在类内进行初始化 

D：静态成员变量必须在类外初始化，静态成员常量在类中初始化。D选项正确。



## 不能声明为虚函数

 1、静态成员函数；2、类外的普通函数；3、构造函数；4、友元函数



## 函数是一种特殊的数据类型

函数指针，比如说int （*p）(int ,int)，p是个函数指针变量，它的类型其实就是函数类型



c++里什么是数据类型? 能用 typedef 的都是数据类型，比如声明一个 int 型的回调函数

 

```
typedef int (*func)();
```

此时`func`就是 一种 `int` 数据类型

 

如果往c语言内核探究，你会发现`int` 关键字之所以是 `int` 类型, 是因为内部用了类似`int()`这样的函数对`int`关键字进行了处理



## \ 转义字符 \1

\ddd   \后跟1到3位0-7之间的数，代表表8进制数\



***\后面三个数字以内都算作1个字符***



 \n代表换行符

 \\\两个斜杠输出\   



## const和#define

![image-20230508100202584](牛客C++专项练习.assets/image-20230508100202584.png)

  A，正确，#define定义的宏是在预处理阶段进行替换的，const常量是在编译、运行阶段进行使用的。 

 

  注意是仅仅的字符串替换，并不会检查其合法性。 

 

  预处理阶段做了的任务： 
 1:将头文件中的内容(源文件之外的文件)插入到源文件中 
 2:进行了宏替换的过程（简单的字符串替换），定义和替换了由#define指令定义的符号 
 3:删除掉注释的过程，注释是不会带入到编译阶段 
 4:条件编译

  B，正确，所有的宏替换只是简单的字符串替换，注意是字符串替换，所以并不会检查其合法性，而const定义的常量依然是内置类型等，所以会对其进行类型安全检查。 

 

  C，正确，宏定义在程序中使用了几次在预处理阶段就会被展开几次，并不会增加内存占用，但是宏定义每展开一次，代码的长度就要发生变化（所以有利必有弊啊！），而const常量也会为其分配内存（如果是动态申请空间肯定就是堆中了）。 

 

  D，错误，const定义的常量只有一次拷贝没毛病，而define定义的变量在内存中并没有拷贝，因为所有的预处理指令都在预处理时进行了替换。



## 常引用

const常类型的作用：使形参在子函数中调用时成为一个常量来使用，既无法成为左值，无法修改形参的值。

引用&的作用：例如a=&b，那么表示a是b的别名，此时a和b的地址相同。在子函数中调用时，形参的改变就是实参的改变，不像C中需要用到指针来实现。

![image-20230508101314037](牛客C++专项练习.assets/image-20230508101314037.png)



## 深拷贝，浅拷贝，浅层复制，深层复制

浅拷贝：**简单的赋值拷贝操作**，其带来的问题：当类内有指针成员变量时，浅拷贝依然会直接赋值，这样释放内存时，会重复释放同一块内存，属于非法操作。  

 

深拷贝：**在堆区重新申请空间，进行拷贝操作**  

 

浅层复制：只复制引用对象的指针，不复制引用对象              



深层赋值：只复制引用对象     

![image-20220927162429341](牛客C++专项练习.assets/image-20220927162429341.png)



## 构造函数创建

![image-20230509100549733](牛客C++专项练习.assets/image-20230509100549733.png)



## sizeof大小

![image-20230510162748752](牛客C++专项练习.assets/image-20230510162748752.png)



![image-20230510162953594](牛客C++专项练习.assets/image-20230510162953594.png)

1.很明显，求的是字符串的长度   

2.求的是指针变量占用的字节数   

3.形式参数是指针，数组名作为实参时，传递的是指针变量

4.形式参数是引用，数组名作为实参时，传递的是数组本身   

5.使用C99语法的复合字面量创建临时数组，本质上求的是两个char元素的数组占用的字节数 

6.char类型的引用，本质上相当于 sizeof(char) 



## 内联函数

 1.内联函数的函数体内不能含有复杂的结构控制语句，如switch和while，否则编译器将该函数视同普通函数那样产生函数调用代码。 

 

  2.递归函数不能被用来作为内联函数。 

 

  3.内联函数一般适合于只有1-5行语句的小函数，对于一个含有很多语句的大函数，没必要使用内联函数来实现。 

 

  4.内联函数的定义必须出现在内联函数第一次被调用之前。 

 

  5.对内联函数不能进行异常接口声明，就是不能声明可能抛出的异常。



## 类模板

具体的不能继承抽象的，抽象的能继承所有具体的



类模板可以继承：模板类、普通类、类模板； 

 

普通类可以继承：模板类、普通类； 

 

模板类是类模板的实例化



## 关系运算符具有左结合性

![image-20230511095528609](牛客C++专项练习.assets/image-20230511095528609.png)

关系运算符具有左结合性，所以表达式（’a'<c<=’z’)将先求’a'<c的值，即为

0（假），再求0<=’z’的值，即为1（真），所以执行if后面的语句printf（"LOW");





## 友元函数

友元函数是可以直接访问类的私有成员的**非成员函数**。它是**定义在类外的普通函数**，它不属于任何类，但需要在类的**定义**中加以声明，声明时只需在友元的名称前加上关键字friend



**友元函数是独立于当前类的外部函数**

一个友元函数可以同时定义为两个类的友元函数，友元函数既可以在类的内部，也可以在类的外部定义

在外部定义友元函数时，不必加关键字friend



友元函数是不能被继承的，可理解为：你父亲的朋友不一定是你自己的朋友 

 

**this指针是指向当前对象的，可以访问当前对象的所有成员，而友元函数是非成员函数，没有this指针** 

 

友元函数并没有破坏继承性机制，因为友元函数是非成员函数，并不会被继承，继承只是继承的成员函数及变量 



## 虚函数继承类大小

![image-20230512100106750](牛客C++专项练习.assets/image-20230512100106750.png)

类的大小只与成员变量（非static数据成员变量）和虚函数指针有关，还要考虑到对齐. 

类A的大小等于4个字节 + 4个字节（考虑对齐） + 4个字节（指向虚函数的指针）=12字节； 

类B的大小就是等于类A的大小12个字节. 因为在基类中存在虚函数时，派生类会继承基类的虚函数，

因此**派生类中不再增加虚函数的存储空间（因为所有的虚函数共享一块内存区域）**，而仅仅需要考虑派生类中添加进来的非static数据成员的内存空间大小。所以类B大小为12B





## 纯虚函数和抽象类

在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容



因此可以将虚函数改为**纯虚函数**



纯虚函数语法：`virtual 返回值类型 函数名 （参数列表）= 0 ;`



***当类中有了纯虚函数，这个类也称为==抽象类==***



**抽象类特点**：

 * 无法实例化对象

 * 子类必须重写抽象类中的纯虚函数，否则也属于抽象类

   

***抽象类特点：***

***抽象类无法实例化对象***

***子类必须重写父类中的纯虚函数，否则也属于抽象类



**先析构子类再析构父类，如果父类析构函数有虚函数，会导致调用子类的已经析构的内容。** 

 **先构造父亲类再构造子类，如果父类构造函数有虚函数，会导致调用子类还没构造的内容。**





##   *(p++) + = 100; 

![image-20230512102125405](牛客C++专项练习.assets/image-20230512102125405.png)

p指向(等价)a[0], 

 

  *(p++) + = 100; 

 

  等价*p + = 100,p++;即a[0]+=100,pl指向a[1]; 

 

  *p = 2,a[0]=101





## nm命令   name

![image-20230515095712686](牛客C++专项练习.assets/image-20230515095712686.png)



**extern "C"指令中的C，表示的一种编译和连接规约，而不是一种语言。C表示符合C语言的编译和连接规约的任何语言，如Fortran、assembler等**



![image-20230515095702267](牛客C++专项练习.assets/image-20230515095702267.png)



## .obj文件

![image-20230516094041459](牛客C++专项练习.assets/image-20230516094041459.png)

一个.cpp文件会生成一个.obj文件，.h文件不会生成.obj文件



## float 类型

![image-20230516094220084](牛客C++专项练习.assets/image-20230516094220084.png)

1 / 2 = 0(先整数运算输出后类型转换)；应改成1.0 / 2。  



## 常函数

普通成员函数后面加上 const 修饰，就是常函数。
常函数中的 this 指针是常指针，**不能在常函数中对成员变量进行修改，只能读取；**
如果想要在常函数中对成员变量进行修改，可以在成员变量前加上 mutable 关键字进行修饰；
常函数可以被普通对象或者常对象调用，但是常对象只能调用常函数，常对象只能读成员。



**类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。**



## union所占字节数

![image-20230516095417820](牛客C++专项练习.assets/image-20230516095417820.png)

32 位机器上int为 4 字节、char 为 1 字节、float 为 4 字节。union 大小为 union 内最大元素的字节数



## strcat()

![image-20230411093717348](牛客C++专项练习.assets/image-20230411093717348.png)

![image-20230518094530951](牛客C++专项练习.assets/image-20230518094530951.png)

字符数组s的大小为10，执行get(ss)；后，等待健盘输入一字符串，由于输

入的是ABC，因此此时ss中存放的字符中是”ABC”，再通过strcat库函数将字符串”6789”

连接到ss当前的字符串”ABC”之后，这样ss中保存的字符串变为”ABC6789”





## fork()

链接：https://www.nowcoder.com/questionTerminal/600f852eeff142199d64a9ee3e6cd1e0?
来源：牛客网

每一个fork()出来的新进程，和父进程使用相同的代码段，复制父进程的数据段和堆栈段，不过有“逻辑”复制和“物理”复制之分，在本题没有影响。也就是说每一个fork()出的新进程和父进程有相同大小的i，并且执行位置也是一样的

    一个进程，包括代码、数据和分配给进程的资源。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。
    一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。

————————————————
版权声明：本文为CSDN博主「jason314」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/jason314/article/details/5640969

![image-20230411095105911](牛客C++专项练习.assets/image-20230411095105911.png)



![image-20230518095737737](牛客C++专项练习.assets/image-20230518095737737.png)

Linux多进程编程中的可以使用fork函数来创建子进程。fork函数定义在头文件unistd.h中（uni表示unix，std当然是标准库，所以很好记），该函数的声明为`pid_t fork(void)`其中函数的返回值类型为pid_t，可以理解为一个整型，返回值具体为：

- **在父进程中，fork返回新创建的子进程的进程ID；**
- **在子进程中，fork返回0；**
- 如果创建子进程失败，则返回一个负值

具体创建的子进程与父进程的关系，很显示fork函数不能接受任何参数，它只简单地将父进程的几乎所有资源全部复制给子进程，然后就相当于父进程的一个副本运行，且无法与父进行共享数据。
具体 来说使用fork函数得到的子进程从父进程继承了整个进程的地址空间，包括：进程上下文、进程堆栈、内存信息、打开的文件描述符、信号控制设置、进程优先级、进程组号、当前工作目录、根目录、资源限制、控制终端等。
**子进程与父进程的区别在于：**

- 父进程设置的锁，子进程不继承（因为如果是排它锁，被继承的话，矛盾了）
- 各自的进程ID和父进程ID不同
- 子进程的未决告警被清除；
- 子进程的未决信号集设置为空集。





## g++ 和 gcc

   首先说明：gcc 和 GCC 是两个不同的东西   

  

   GCC:GNU Compiler Collection(GUN 编译器集合)，它可以编译C、C++、JAV、Fortran、Pascal、Object-C、Ada等语言。   

  

   gcc是GCC中的GUN C Compiler（C 编译器）   

  

   g++是GCC中的GUN C++ Compiler（C++编译器）



***g++编译.c和.cpp都按照.cpp来搞，      gcc对于c和cpp不一样***





## 基类指针调用虚函数

![image-20230520135926332](牛客C++专项练习.assets/image-20230520135926332.png)

***实现动态联编用父类指针或应用指向子类对象***



## 静态成员变量没有this指针

![image-20230520140354694](牛客C++专项练习.assets/image-20230520140354694.png)

![image-20230520140341711](牛客C++专项练习.assets/image-20230520140341711.png)



## define预处理

![image-20230522100126525](牛客C++专项练习.assets/image-20230522100126525.png)

undef 会重新define a， 但define 执行的时候，就一直替换到文件末尾，main中a都被替换了，进foo定义，遇到undef之后重新define成50. 如果foo放在前面，开始define替换，先遇到undef a替换成50，再从main到结尾全替换成50   

***凡是以#号开头的行，都被称为编译预处理命令行***





## BSS段

![image-20230522100909785](牛客C++专项练习.assets/image-20230522100909785.png)

BSS段：通常是指用来存放程序中**未初始化**的全局变量的一块内存区域； 

数据段：通常是指用来存放程序中 **已初始化** **的** **全局变量** 的一块内存区域，static意味着在数据段中存放变量； 

代码段：通常是指用来存放程序执行代码 的一块内存区域；  

堆：存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减，这一块在程序运行前就已经确定了； 

栈：栈又称堆栈， 存放程序的 局部变量 （不包括static声明的变量）。除此以外，在函数被调用时，栈用来传递参数和返回值。





## \#import是#include的替代指令，防止重复引用



## abs（）  求整数的绝对值

![image-20230523095235884](牛客C++专项练习.assets/image-20230523095235884.png)

因为负数的范围比正数大一个,比如8位的二进制，可以表示范围为-128~127 所以abs(-128)可能并不能表示为128 所以只能返回原值



## static 类型无法再使用extern

在外部变量的定义前面加上关键字static，就表示定义了一个外部静态变量。

外部静态变量具有全局的作用域和全局的生存期，

***定义成static类型的外部变量将无法再使用extern将其作用范围扩展到其他文件中，***

而是被限制在了本身所在的文件内，为程序的模块化、通用性提供方便。



全局变量(外部变量)



## 类占用空间   \#pragma pack(2)  强制设定为2字节对齐 

![image-20230524102137593](牛客C++专项练习.assets/image-20230524102137593.png)

代码开头的 #pragma pack(2) 意味着强制2字节对齐 

 

  int i 占4个字节 

 

  union是共享内存空间的，并且union所占的字节数由里面最大元素决定！因此char buff[13]和int i共享内存空间，由于2字节对齐，因此13+1，共占14个字节 

 

  成员函数不占内存空间 

 

  typedef是类型别名也不占内存空间，如果typedef去掉 就是一个指针 这个时候就要占内存空间 32位机器是4字节，64位机器是8字节 

 

  ***对于enum，规定其占一个int的大小，4个字节*** 



## enum枚举类型

枚举是 C 语言中的一种基本数据类型，用于定义一组具有离散值的常量。它可以让数据更简洁，更易读。

枚举类型通常用于为程序中的一组相关的常量取名字，以便于程序的可读性和维护性。

定义一个枚举类型，需要使用 **enum** 关键字，后面跟着枚举类型的名称，以及用大括号 **{}** 括起来的一组枚举常量。每个枚举常量可以用一个标识符来表示，也可以为它们指定一个整数值，如果没有指定，那么默认从 **0** 开始递增。

枚举语法定义格式为：

```
enum　枚举名　{枚举元素1,枚举元素2,……};
```

接下来我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：

\#define MON  1 #define TUE  2 #define WED  3 #define THU  4 #define FRI  5 #define SAT  6 #define SUN  7

这个看起来代码量就比较多，接下来我们看看使用枚举的方式：

```
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
```

这样看起来是不是更简洁了。

**注意：**第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。

> 可以在定义枚举类型时改变枚举元素的值：
>
> ```
> enum season {spring, summer=3, autumn, winter};
> ```
>
> 没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5





前面我们只是声明了枚举类型，接下来我们看看如何定义枚举变量。

我们可以通过以下三种方式来定义枚举变量

**1、先定义枚举类型，再定义枚举变量**

```
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
enum DAY day;
```

**2、定义枚举类型的同时定义枚举变量**

```
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
```

**3、省略枚举名称，直接定义枚举变量**

```
enum
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
```





## 32位系统和64位系统中各个变量类型占的字节数

![image-20230526095000181](牛客C++专项练习.assets/image-20230526095000181.png)

![image-20230526095129845](牛客C++专项练习.assets/image-20230526095129845.png)



## map

map是红黑树,中序遍历有序;

unordered_map是哈希表,属于无序存储



map和multimap**区别**：

- map不允许容器中有重复key值元素
- multimap允许容器中有重复key值元素



## void * 为无类型指针

![image-20230528094358074](牛客C++专项练习.assets/image-20230528094358074.png)

https://blog.csdn.net/W_H_M_2018/article/details/111120624



## 纯虚函数--抽象类

***一个基类有纯虚函数，则基类肯定是抽象类，如果该基类的派生类没有实现基类中的纯虚函数，则该派生类也是抽象类。***



## 常对象只能调用常成员函数

如果一个对象说明为常对象，则通过该对象只能调用它的常成员函数。



## 算法5大特性

一个算法应该具有以下五个重要的特征：  　　

1、有穷性： 一个算法必须保证执行有限步之后结束；  　　

2、确切性： 算法的每一步骤必须有确切的定义；  　　

3、输入：一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定除了初始条件； 　

4、输出：一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的；  　　

5、可行性： 算法原则上能够精确地运行，而且人们用笔和纸做有限次运算后即可完成。



## 类的初始化

  A：静态函数属于类本身，不与类绑定，因此不能用this指针。A选项正确。  

  B：在类定义时，无法使用构造函数，因而无法完成对象的初始化  

  C：一般成员变量需要在类内进行初始化  

  D：静态成员变量必须在类外初始化，静态成员常量在类中初始化。D选项正确



## %*4s  %2d

 %4s表示读取一个长度为四个字符的字符串，中间的表示将读取到的字符串忽略，不赋给变量列表中的变量



％2d先读取前两个字符



## inline

内联函数与其他普通函数的区别是，内联函数在生成可执行文件时，其代码块是直接嵌入到调用处的，以此减少函数调用的开销提高程序性能，它与宏很类似。

但是，C++ primer 上明明白白的写过这么一句话：内联说明（inline specification）对于编译器来说只是一个建议，编译器可以选择忽略这个建议。也就是说，是否以嵌入式方式存在，是由编译器决定的，并不是一定。



什么叫类型安全的语言？本人很浅陋的认识是：就C++而言，我们可以把0作为false，非零作为true。一个函数就算是bool类型的，我们还是可以返回int类型，并且自动把0转化成false，非零转化成true。相比之下java不能把int类型转化成bool类型。所以java是一种类型安全的语言，而C++并不是。





## cast

**C++中强制类型转换操作符有static_cast、dynamic_cast、const_cast、reinterpert_cast四个**

```
dynamic_cast<new_type>(expression)要求new_type一定要是多态类型的类（存在虚函数），否则编译不通过，dynamic_cast可以检测上下行转换，当发现是下行转换时，得到null（将基类指针转换为子类是不安全的），但如果new_type是void*类型时，dynamic_cast认为总是安全的。
```

```
dynamic_cast将一个基类对象指针（或引用）cast到继承类指针，dynamic_cast会根据基类指针是否真正指向继承类指针来做相应处理， 即会作一定的判断。 对指针进行dynamic_cast，失败返回null，成功返回正常cast后的对象指针； 对引用进行dynamic_cast，失败抛出一个异常，成功返回正常cast后的对象引用。 
reinterpret_cast这个转换是最“不安全”的，两个没有任何关系的类指针之间转换都可以用这个转换实现。
static_cast静态转换是最接近于C风格转换，很多时候都需要程序员自身去判断转换是否安全。
const_cast这个转换好理解，可以将常量转成非常量。
```









